#代码规范
[toc]

## 缩进
4个空格常被作为缩进排版的一个单位，以表示缩进，显示程序的层次级别，增加程序的可读性。

## 变量命名
1、代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。

说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。 注意，即使纯拼音命名方式也要避免采用。

2、代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。

3、方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。

4、杜绝完全不规范的缩写，避免望文不知义。

## 每行最多字符数
较长的语句（>80 字符）要分成多行书写 ）要分成多行书写。
说明：
以下情况应分多行书写：
1）长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行
要进行适当的缩进，使排版整齐，语句可读。
2）若函数或过程中的参数较长，则要进行适当的划分。
3）循环、判断等语句中若有较长的表达式或语句，则要进行适应的划分，长表达式
要在低优先级操作符处划分新行，操作符放在新行之首。

## 函数最大行数
在网上查到当函数行数到达10行以上，函数复杂度就开始大幅度攀升。
当代码行数达到20行时（复杂度400），其复杂度已经是14行时（复杂度 196）的2倍。
因此我将最大行数代码规范定在15行。

## 函数、类命名
1、类名使用UpperCamelCase风格，必须遵从驼峰形式。

2、抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。

3、方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。


## 常量
1、常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。

2、不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。

3、long或者Long初始赋值时，必须使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。

## 空行规则
空行将逻辑相关的代码段分隔开，以提高可读性。下列情况应该总是使用两个空行：
Ø        一个源文件的两个片段(section)之间
Ø         类声明和接口声明之间
下列情况应该总是使用一个空行：
Ø        两个方法之间
Ø        方法内的局部变量和方法的第一条语句之间
Ø        块注释或单行注释之前
Ø        一个方法内的两个逻辑段之间，用以提高可读性

## 注释规则
1、代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。

2、注释掉的代码尽量要配合说明，而不是简单的注释掉。

3、对于注释的要求：

第一、能够准确反应设计思想和代码逻辑；
第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。

4、特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。

## 操作符前后空格
下列情况应该使用空格：
Ø 一个紧跟着括号的关键字应该被空格分开，例如：
  while (true) {
      ...
  }
  
注意：空格不应该置于方法名与其左括号之间。这将有助于区分关键字和方法调用。
Ø 空白应该位于参数列表中逗号的后面
Ø 所有的二元运算符，除了"."，应该使用空格将之与操作数分开。一元操作符和操作数之间不因该加空格，比如：负号("-")、自增("++")和自减("--")。
Ø for语句中的表达式应该被空格分开，例如：
for (expr1; expr2; expr3)
Ø 强制转型后应该跟一个空格

## 其他规则
### 换行规则
当一个表达式无法容纳在一行内时，可以依据如下一般规则断开之：
Ø        在一个逗号后面断开
Ø        在一个操作符前面断开
Ø        宁可选择较高级别(higher-level)的断开，而非较低级别(lower-level)的断开
Ø        新的一行应该与上一行同一级别表达式的开头处对齐
Ø        如果以上规则导致你的代码混乱或者使你的代码都堆挤在右边，那就代之以缩进8个空格。

### 表达式圆括号
由于不能保证所有人都清楚Java操作符优先级，因此推荐在表达式中增加圆括号用来明确其中运算的优先级。
（不做强制要求）

### 修饰符
当同时使用多个修饰符时，按照下列顺序：
public protected private abstract static final transient volatile synchronized native strictfp